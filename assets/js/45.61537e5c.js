(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{438:function(e,a,t){"use strict";t.r(a);var i=t(5),s=Object(i.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"capability"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#capability"}},[e._v("#")]),e._v(" Capability")]),e._v(" "),t("div",{staticClass:"custom-block warning"},[t("p",{staticClass:"custom-block-title"},[e._v("NOTE")]),e._v(" "),t("p",[e._v("Terra's capability module inherits from Cosmos SDK's "),t("a",{attrs:{href:"https://docs.cosmos.network/master/modules/capability/",target:"_blank",rel:"noopener noreferrer"}},[t("code",[e._v("capability")]),t("OutboundLink")],1),e._v(" module. This document is a stub, and covers mainly important Terra-specific notes about how it is used.")])]),e._v(" "),t("p",[e._v("The capability module allows you to provision, track, and authenticate multi-owner capabilities at runtime.")]),e._v(" "),t("p",[e._v("The keeper maintains two states: persistent and ephemeral in-memory. The persistent state maintains a globally unique autoincrementing index and a map from the capability index to a set of capability owners that are defined as a module and a capability name tuple. The ephemeral in-memory state tracks the actual capabilities, represented as addresses in local memory, with both forward and reverse indexes. The forward index maps the module name and capability tuples to the capability name. The reverse index maps the module and capability name to the capability itself.")]),e._v(" "),t("p",[e._v("The keeper allows the creation of scoped subkeepers, which are tied to a particular module by name. Scoped subkeepers must be created and passed to modules when you initialize the application. Then, the modules can use them to claim capabilities they receive and retrieve capabilities that they own by name. Additionally, they can create new capabilities and authenticate capabilities passed by other modules. A scoped subkeeper cannot escape its scope, so a module cannot interfere with or inspect capabilities owned by other modules.")]),e._v(" "),t("p",[e._v("The keeper provides no other core functionality that can be found in other modules, such as queriers, REST and CLI handlers, and the genesis state.")]),e._v(" "),t("h2",{attrs:{id:"initialization"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#initialization"}},[e._v("#")]),e._v(" Initialization")]),e._v(" "),t("p",[e._v("When you initialize the application, the keeper must be instantiated with a persistent store key and an ephemeral in-memory store key.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("type App struct {\n  // ...\n\n  capabilityKeeper *capability.Keeper\n}\n\nfunc NewApp(...) *App {\n  // ...\n\n  app.capabilityKeeper = capability.NewKeeper(codec, persistentStoreKey, memStoreKey)\n}\n")])])]),t("p",[e._v("After the keeper is created, it can create scoped subkeepers, which are passed to other modules that can create, authenticate, and claim capabilities. After all the necessary scoped subkeepers are created and the state is loaded, you must initialize and seal the main capability keeper to populate the ephemeral in-memory state and to prevent more scoped subkeepers from being created.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("func NewApp(...) *App {\n  // ...\n\n  // Initialize and seal the capability keeper so all persistent capabilities\n  // are loaded in-memory and prevent any further modules from creating scoped\n  // sub-keepers.\n  ctx := app.BaseApp.NewContext(true, tmproto.Header{})\n  app.capabilityKeeper.InitializeAndSeal(ctx)\n\n  return app\n}\n")])])]),t("h2",{attrs:{id:"concepts"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#concepts"}},[e._v("#")]),e._v(" Concepts")]),e._v(" "),t("p",[e._v("Capabilities are multi-owner. A scoped subkeeper can create a capability via "),t("code",[e._v("NewCapability,")]),e._v(" which creates a unique, unforgeable, object-capability reference. The newly created capability is automatically persisted. The calling module does not need to call "),t("code",[e._v("ClaimCapability")]),e._v(". Calling "),t("code",[e._v("NewCapability")]),e._v(" creates the capability with the calling module and name as a tuple to be the capabilities first owner.")]),e._v(" "),t("p",[e._v("Capabilities can be claimed by other modules, which add them as owners. "),t("code",[e._v("ClaimCapability")]),e._v(" allows a module to claim a capability key that it has received from another module so that "),t("code",[e._v("GetCapability")]),e._v(" calls made later will succeed. If a module that receives a capability wants to access it by name later, "),t("code",[e._v("ClaimCapability")]),e._v(" must be called. Because capabilities are multi-owner, if multiple modules have one capability reference, all the modules own it. If a module receives a capability from another module but does not call "),t("code",[e._v("ClaimCapability")]),e._v(", it may use it in the executing transaction but will not be able to access it afterward.")]),e._v(" "),t("p",[e._v("Any module can call "),t("code",[e._v("AuthenticateCapability")]),e._v(" to check whether a capability corresponds to a particular name, including un-trusted user input, with which the calling module previously associated it.")]),e._v(" "),t("p",[t("code",[e._v("GetCapability")]),e._v(" allows a module to fetch a capability that it has previously claimed by name. The module is not allowed to retrieve capabilities that it does not own.")]),e._v(" "),t("h3",{attrs:{id:"stores"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#stores"}},[e._v("#")]),e._v(" Stores")]),e._v(" "),t("ul",[t("li",[e._v("MemStore")])]),e._v(" "),t("h2",{attrs:{id:"states"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#states"}},[e._v("#")]),e._v(" States")]),e._v(" "),t("ul",[t("li",[e._v("Index")]),e._v(" "),t("li",[e._v("CapabilityOwners")]),e._v(" "),t("li",[e._v("Capability")])])])}),[],!1,null,null,null);a.default=s.exports}}]);